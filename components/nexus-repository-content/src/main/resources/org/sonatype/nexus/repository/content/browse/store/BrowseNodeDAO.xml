<?xml version="1.0" encoding="UTF-8" ?>
<!--

    Sonatype Nexus (TM) Open Source Version
    Copyright (c) 2008-present Sonatype, Inc.
    All rights reserved. Includes the third-party code listed at http://links.sonatype.com/products/nexus/oss/attributions.

    This program and the accompanying materials are made available under the terms of the Eclipse Public License Version 1.0,
    which accompanies this distribution and is available at http://www.eclipse.org/legal/epl-v10.html.

    Sonatype Nexus (TM) Professional Version is available from Sonatype, Inc. "Sonatype" and "Sonatype Nexus" are trademarks
    of Sonatype, Inc. Apache Maven is a trademark of the Apache Software Foundation. M2eclipse is a trademark of the
    Eclipse Foundation. All other trademarks are the property of their respective owners.

-->
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="${namespace}">

  <insert id="createSchema">
    --
    -- each format has a browse node table
    --
    CREATE TABLE IF NOT EXISTS ${format}_browse_node (
      node_id       BIGINT GENERATED BY DEFAULT AS IDENTITY,
      repository_id INT NOT NULL,
      parent_id     BIGINT NOT NULL,
      display_name  VARCHAR NOT NULL,
      request_path  VARCHAR NOT NULL,
      component_id  INT,
      asset_id      INT,
      package_url   VARCHAR,

      CONSTRAINT pk_${format}_browse_node_id PRIMARY KEY (node_id),
      CONSTRAINT uk_${format}_browse_node_repository_path UNIQUE (repository_id, request_path),
      CONSTRAINT uk_${format}_browse_node_asset UNIQUE (asset_id),

      CONSTRAINT fk_${format}_browse_node_repository_id FOREIGN KEY (repository_id)
         REFERENCES ${format}_content_repository (repository_id) ON DELETE CASCADE,
      CONSTRAINT fk_${format}_browse_node_component FOREIGN KEY (component_id)
         REFERENCES ${format}_component (component_id) ON DELETE SET NULL,
      CONSTRAINT fk_${format}_browse_node_asset FOREIGN KEY (asset_id)
         REFERENCES ${format}_asset (asset_id) ON DELETE SET NULL

      -- skip FK for parent_id; doesn't work well when batch deleting from the root
    );

    CREATE UNIQUE INDEX IF NOT EXISTS uk_${format}_browse_node_parent_display
        ON ${format}_browse_node (repository_id, parent_id, display_name);

    CREATE INDEX IF NOT EXISTS idx_${format}_browse_node_asset_id
        ON ${format}_browse_node (asset_id);

    CREATE INDEX IF NOT EXISTS idx_${format}_browse_node_component_id
        ON ${format}_browse_node (component_id);
    --
  </insert>

  <resultMap id="browseNodeResult" type="BrowseNodeData">
    <!-- non-standard field mappings -->
    <result property="dbComponentId" column="component_id"/>
    <result property="dbAssetId" column="asset_id"/>
    <result property="lastUpdated" column="last_updated"/>
  </resultMap>

  <sql id="hasChild">
    SELECT 1 FROM ${format}_browse_node C WHERE C.repository_id = #{repositoryId} AND C.parent_id = B.node_id LIMIT 1
  </sql>

  <select id="hasComponentNode" resultType="boolean">
    SELECT EXISTS(SELECT 1 FROM ${format}_browse_node WHERE component_id = #{componentId});
  </select>

  <select id="hasAssetNode" resultType="boolean">
    SELECT EXISTS(SELECT 1 FROM ${format}_browse_node WHERE asset_id = #{assetId});
  </select>

  <select id="getByDisplayPath" resultMap="browseNodeResult">
    <bind name="isConanFormat" value="'${format}' == 'conan'"/>
    SELECT B.*,
      <if test="isConanFormat">
        COALESCE(C.last_updated, A.last_updated) AS last_updated,
      </if>
        NOT EXISTS (<include refid="hasChild"/>) as leaf FROM
        <foreach collection="displayPath" index="i">
        ${format}_browse_node B${i},
        </foreach>
        ${format}_browse_node B
    <if test="isConanFormat">
      LEFT JOIN ${format}_component C ON B.component_id = C.component_id
      LEFT JOIN ${format}_asset A ON B.asset_id = A.asset_id
    </if>
    WHERE 0 = <foreach collection="displayPath" index="i" item="name">
              B${i}.parent_id AND B${i}.repository_id = #{repositoryId} AND B${i}.display_name = #{name} AND B${i}.node_id =
              </foreach>
              B.parent_id AND B.repository_id = #{repositoryId}
        <if test="filter != null and filter != ''"> AND (${filter})</if>
        <if test="limit gt 0"> LIMIT #{limit}</if>;
  </select>

  <insert id="mergeBrowseNode" useGeneratedKeys="true" keyProperty="nodeId" parameterType="BrowseNodeData">
    MERGE INTO ${format}_browse_node AS B
         USING (SELECT 1
                  FROM DUAL)
            ON (B.repository_id = #{repositoryId} AND
                B.parent_id = #{parentId} AND
                B.display_name = #{displayName})
    WHEN NOT MATCHED THEN
           INSERT (repository_id, request_path, display_name, parent_id, package_url, component_id, asset_id)
           VALUES (#{repositoryId}, #{requestPath}, #{displayName}, #{parentId}, #{packageUrl},
                   #{dbComponentId}, #{dbAssetId})
    <if test="dbComponentId != null || dbAssetId != null || requestPath.endsWith('/')">
    WHEN MATCHED THEN UPDATE
                       <set>
                         <if test="dbComponentId != null">B.component_id = #{dbComponentId}</if>
                         <if test="dbAssetId != null">, B.asset_id = #{dbAssetId}</if>
                         <if test="requestPath.endsWith('/')">, B.request_path = #{requestPath}</if>
                       </set>
    </if>;
  </insert>

  <insert id="mergeBrowseNode" useGeneratedKeys="true" keyProperty="nodeId" parameterType="BrowseNodeData" databaseId="PostgreSQL">
    INSERT INTO ${format}_browse_node (repository_id, request_path, display_name, parent_id, package_url
        <if test="dbComponentId != null">, component_id</if>
        <if test="dbAssetId != null">, asset_id</if>
    )
    VALUES (#{repositoryId}, #{requestPath}, #{displayName}, #{parentId}, #{packageUrl}
        <if test="dbComponentId != null">, #{dbComponentId}</if>
        <if test="dbAssetId != null">, #{dbAssetId}</if>
    )
    ON CONFLICT (repository_id, parent_id, display_name)
        DO UPDATE
    <choose>
      <when test="!requestPath.endsWith('/') &amp;&amp; dbComponentId == null &amp;&amp; dbAssetId == null">
        SET display_name = ${format}_browse_node.display_name
      </when>
      <otherwise>
          <set>
            <if test="requestPath.endsWith('/')">request_path = #{requestPath}</if>
            <if test="dbComponentId != null">, component_id = #{dbComponentId}, package_url = #{packageUrl}</if>
            <if test="dbAssetId != null">, asset_id = #{dbAssetId}</if>
          </set>
      </otherwise>
    </choose>
    RETURNING node_id
    ;
  </insert>

  <delete id="trimBrowseNodes">
    DELETE FROM ${format}_browse_node B WHERE
        B.repository_id = #{repositoryId} AND B.component_id IS NULL AND B.asset_id IS NULL AND
        NOT EXISTS (SELECT 1 FROM ${format}_browse_node C WHERE
            C.repository_id = #{repositoryId} AND C.parent_id = B.node_id LIMIT 1);
  </delete>

  <delete id="deleteBrowseNodes">
    DELETE FROM ${format}_browse_node WHERE
        repository_id = #{repositoryId}
        <if test="limit gt 0"> LIMIT #{limit}</if>;
  </delete>

  <delete id="deleteBrowseNodes" databaseId="PostgreSQL">
    DELETE FROM ${format}_browse_node WHERE
        <if test="limit gt 0"> node_id IN (SELECT node_id FROM ${format}_browse_node WHERE </if>
        repository_id = #{repositoryId}
        <if test="limit gt 0"> LIMIT #{limit})</if>;
  </delete>
  <select id="deleteByAssetIdAndPath" resultType="Long" databaseId="PostgreSQL">
    DELETE FROM ${format}_browse_node WHERE
        asset_id = #{internalAssetId} AND request_path = #{path}
    RETURNING parent_id;
  </select>
  <select id="getNodeParents" resultMap="browseNodeResult" databaseId="PostgreSQL">
    WITH total as (
      WITH RECURSIVE parent_nodes AS (
        SELECT *
        FROM ${format}_browse_node
        WHERE node_id = #{internalNodeId}
        UNION ALL
        SELECT t.*
        FROM ${format}_browse_node t
        INNER JOIN parent_nodes pn ON t.node_id = pn.parent_id
      )
      SELECT *
      FROM parent_nodes
      WHERE parent_id IS NOT NULL
    )
    select  parent.node_id, parent.repository_id,
            parent.parent_id, parent.display_name,
            parent.request_path, parent.component_id,
            parent.asset_id, parent.package_url,
            SUM(CASE WHEN children.asset_id IS NOT NULL THEN 1 ELSE 0 END) AS asset_count
    from    total parent
            left join ${format}_browse_node children on
            parent.node_id = children.parent_id
    group by parent.node_id, parent.repository_id,
             parent.parent_id, parent.display_name,
             parent.request_path, parent.component_id,
             parent.asset_id, parent.package_url
    order by parent.request_path desc;
  </select>
  <delete id="delete">
    DELETE FROM ${format}_browse_node WHERE
        node_id = #{internalNodeId};
  </delete>

  <select id="getByRequestPath" resultMap="browseNodeResult">
    SELECT * FROM ${format}_browse_node C WHERE
        C.repository_id = #{repositoryId} AND C.request_path = #{requestPath};
  </select>

  <select id="getChildByParentNodeId" resultMap="browseNodeResult">
    SELECT * FROM ${format}_browse_node WHERE
        parent_id = #{parentNodeId}
    <if test="limit gt 0"> LIMIT #{limit} OFFSET #{offset}</if>;
    </select>
</mapper>
