<?xml version="1.0" encoding="UTF-8" ?>
<!--

    Sonatype Nexus (TM) Open Source Version
    Copyright (c) 2008-present Sonatype, Inc.
    All rights reserved. Includes the third-party code listed at http://links.sonatype.com/products/nexus/oss/attributions.

    This program and the accompanying materials are made available under the terms of the Eclipse Public License Version 1.0,
    which accompanies this distribution and is available at http://www.eclipse.org/legal/epl-v10.html.

    Sonatype Nexus (TM) Professional Version is available from Sonatype, Inc. "Sonatype" and "Sonatype Nexus" are trademarks
    of Sonatype, Inc. Apache Maven is a trademark of the Apache Software Foundation. M2eclipse is a trademark of the
    Eclipse Foundation. All other trademarks are the property of their respective owners.

-->
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="${namespace}">
  <insert id="createSchema" databaseId="PostgreSQL">
    CREATE TABLE IF NOT EXISTS ${format}_key_value (
      key_value_id    INT GENERATED BY DEFAULT AS IDENTITY,
      repository_id   INT NOT NULL,
      category        VARCHAR NOT NULL,
      key             VARCHAR NOT NULL,
      value           VARCHAR,
      created         TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,

      CONSTRAINT pk_${format}_key_value_id PRIMARY KEY (key_value_id)
    );

    CREATE UNIQUE INDEX IF NOT EXISTS uk_${format}_repository_category_key
        ON ${format}_key_value (repository_id, category, key);

    CREATE INDEX IF NOT EXISTS idx_${format}_key_value_repository_key
        ON ${format}_key_value(repository_id, key);
  </insert>

  <insert id="createSchema" databaseId="H2">
    CREATE TABLE IF NOT EXISTS ${format}_key_value (
       key_value_id    INT GENERATED BY DEFAULT AS IDENTITY,
       repository_id   INT NOT NULL,
       category        VARCHAR NOT NULL,
       `key`             VARCHAR NOT NULL,
       `value`           CHARACTER LARGE OBJECT,
       created         TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,

       CONSTRAINT pk_${format}_key_value_id PRIMARY KEY (key_value_id)
    );

    CREATE UNIQUE INDEX IF NOT EXISTS uk_${format}_repository_category_key
      ON ${format}_key_value (repository_id, category, `key`);

    CREATE INDEX IF NOT EXISTS idx_${format}_key_value_repository_key
      ON ${format}_key_value(repository_id, `key`);
  </insert>

  <resultMap id="kvResult" type="org.sonatype.nexus.repository.content.kv.KeyValue">
    <!-- non-standard field mappings -->
    <result property="keyValueId" column="key_value_id"/>
    <result property="category" column="category"/>
    <result property="key" column="key"/>
    <result property="value" column="value"/>
  </resultMap>

  <select id="browse" resultMap="kvResult" databaseId="PostgreSQL">
      SELECT key_value_id, category, key, value
        FROM ${format}_key_value
       WHERE repository_id = #{repositoryId}
         AND category = #{category}
         <if test="continuationToken != null"> AND key > #{continuationToken}</if>
       ORDER BY key
       LIMIT #{limit};
  </select>

  <select id="browse" resultMap="kvResult" databaseId="H2">
    SELECT key_value_id, category, `key`, `value`
    FROM ${format}_key_value
    WHERE repository_id = #{repositoryId}
    AND category = #{category}
    <if test="continuationToken != null"> AND `key` > #{continuationToken}</if>
    ORDER BY `key`
    LIMIT #{limit};
  </select>

  <select id="browseCategories" resultType="String">
      SELECT DISTINCT category
        FROM ${format}_key_value
       WHERE repository_id = #{repositoryId};
  </select>

  <select id="count" resultType="int">
      SELECT count(*)
        FROM ${format}_key_value
       WHERE repository_id = #{repositoryId}
       <if test="category != null"> AND category = #{category}</if>;
  </select>

  <select id="findCategories" resultType="String" databaseId="PostgreSQL">
    SELECT category
      FROM ${format}_key_value
     WHERE repository_id = #{repositoryId}
       AND key = #{key};
  </select>

  <select id="findCategories" resultType="String" databaseId="H2">
    SELECT category
    FROM ${format}_key_value
    WHERE repository_id = #{repositoryId}
      AND `key` = #{key};
  </select>

  <select id="get" resultType="String" databaseId="PostgreSQL">
      SELECT value
        FROM ${format}_key_value
       WHERE repository_id = #{repositoryId}
         AND category = #{category}
         AND key = #{key};
  </select>

  <select id="get" resultType="String" databaseId="H2">
    SELECT `value`
    FROM ${format}_key_value
    WHERE repository_id = #{repositoryId}
      AND category = #{category}
      AND `key` = #{key};
  </select>

  <select id="findByCategoryAndKeyLike" resultMap="kvResult" databaseId="PostgreSQL">
    SELECT key_value_id, category, key, value
      FROM ${format}_key_value
     WHERE repository_id = #{repositoryId}
       <if test="category != null"> AND category = #{category}</if>
       AND key LIKE #{keyLike};
  </select>

  <select id="findByCategoryAndKeyLike" resultMap="kvResult" databaseId="H2">
    SELECT key_value_id, category, `key`, `value`
    FROM ${format}_key_value
    WHERE repository_id = #{repositoryId}
    <if test="category != null"> AND category = #{category}</if>
    AND `key` LIKE #{keyLike};
  </select>

  <update id="set" databaseId="PostgreSQL">
         INSERT INTO ${format}_key_value (repository_id, category, key, value, created)
         VALUES (#{repositoryId}, #{category}, #{key}, #{value}, now())
    ON CONFLICT (repository_id, category, key)
  DO UPDATE SET value = #{value},
                created = now();
  </update>

  <update id="set" databaseId="H2">
    MERGE INTO ${format}_key_value
         USING (SELECT 1
                  FROM DUAL)
            ON (repository_id = #{repositoryId} AND
               category = #{category} AND
                `key` = #{key})
          WHEN NOT MATCHED THEN
               INSERT (repository_id, category, `key`, `value`)
               VALUES (#{repositoryId}, #{category}, #{key}, #{value})
          WHEN MATCHED THEN UPDATE SET `value` = #{value},
                                       created = now();
  </update>

  <delete id="remove" databaseId="PostgreSQL">
    DELETE FROM ${format}_key_value
          WHERE repository_id = #{repositoryId}
            AND category = #{category}
            AND key = #{key};
  </delete>

  <delete id="remove" databaseId="H2">
    DELETE FROM ${format}_key_value
    WHERE repository_id = #{repositoryId}
      AND category = #{category}
      AND `key` = #{key};
  </delete>

  <delete id="removeAll">
    DELETE FROM ${format}_key_value
     WHERE repository_id = #{repositoryId}
      <if test="category != null"> AND category = #{category}</if>
      <if test="limit gt 0"> LIMIT #{limit}</if>;
  </delete>

  <delete id="removeAll" databaseId="PostgreSQL">
    DELETE FROM ${format}_key_value
     WHERE key_value_id IN (SELECT key_value_id
                              FROM ${format}_key_value
                             WHERE repository_id = #{repositoryId}
                                <if test="category != null"> AND category = #{category}</if>
      <if test="limit gt 0"> LIMIT #{limit}</if>);
  </delete>

  <delete id="removeRepository">
    DELETE FROM ${format}_key_value
     WHERE repository_id = #{repositoryId}
     <if test="limit gt 0"> LIMIT #{limit}</if>;
  </delete>

  <delete id="removeRepository" databaseId="PostgreSQL">
    DELETE FROM ${format}_key_value
     WHERE key_value_id IN (SELECT key_value_id
                             FROM ${format}_key_value
                            WHERE repository_id = #{repositoryId}
     <if test="limit gt 0"> LIMIT #{limit}</if>);
  </delete>
</mapper>
